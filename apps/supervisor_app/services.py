from __future__ import annotations

import html
import json
import shutil
from pathlib import Path
from typing import Iterable, Optional

from PySide6.QtWidgets import QMessageBox, QWidget

from apps.supervisor_app.latex_workspace import (
    LatexWorkspace,
    load_comments_json,
    save_comments_json,
)
from shared.detect import detect_manuscript_type
from shared.due import write_return_due
from shared.events import returned_event, write_event
from shared.latex.builder import build_pdf, detect_main_tex
from shared.latex.diff import build_diff_pdf
from shared.models import ManuscriptType
from shared.osutil import open_with_default_app
from shared.timeutil import iso_to_local_str

from .data import SubmissionInfo


def write_latex_review_html(dst: Path, title: str, has_pdf: bool,
                            pdf_path: Optional[Path], build_log: str,
                            payload: Path, comments: Optional[dict] = None) -> None:
    dst.parent.mkdir(parents=True, exist_ok=True)
    log_escaped = html.escape(build_log or "", quote=False)
    tex_files = "\n".join(
        f"<li>{html.escape(str(p.relative_to(payload)))}</li>"
        for p in sorted(payload.rglob("*.tex"))
    )
    pdf_block = ""
    if has_pdf and pdf_path and pdf_path.exists():
        pdf_rel = html.escape(pdf_path.name)
        pdf_block = f'<p><a href="{pdf_rel}">Open {pdf_rel}</a></p><embed src="{pdf_rel}" type="application/pdf" width="100%" height="800px"/>'
    comments_block = ""
    if comments:
        general = html.escape(comments.get("general", "") or "")
        items_html = ""
        for it in comments.get("items", []):
            file_ = html.escape(str(it.get("file", "")))
            ls = it.get("line_start", it.get("line", ""))
            le = it.get("line_end", ls)
            rng = f"{ls}-{le}" if (ls and le and ls != le) else f"{ls}"
            text_ = html.escape(str(it.get("text", "")))
            items_html += f"<li><code>{file_}:{rng}</code> — {text_}</li>\n"
        comments_block = f"""
        <details open>
          <summary><strong>Comments</strong></summary>
          <h4>General notes</h4>
          <pre>{general}</pre>
          <h4>Itemised</h4>
          <ul>{items_html}</ul>
        </details>"""

    html_text = f"""<!doctype html><meta charset="utf-8"/>
<title>LaTeX Review – {html.escape(title)}</title>
<style>body{{font-family:-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px}}code,pre{{background:#f5f5f5;padding:8px;border-radius:6px}}</style>
<h1>LaTeX Review — {html.escape(title)}</h1>
{pdf_block}
{comments_block}
<details><summary><strong>Build log</strong></summary><pre>{log_escaped}</pre></details>
<details><summary><strong>Source files (.tex)</strong></summary><ul>{tex_files}</ul></details>
<p><em>Generated by Supervisor app.</em></p>"""
    dst.write_text(html_text, encoding="utf-8")

def open_submission(parent: QWidget, info: SubmissionInfo) -> None:
    subdir = info.manuscript_root / "submissions" / info.submission_id
    payload = info.payload_dir
    mtype = info.mtype
    reviews_dir = info.reviews_dir
    reviews_dir.mkdir(parents=True, exist_ok=True)

    if mtype == ManuscriptType.DOCX:
        primary = None
        for ext in (".docx", ".doc"):
            for p in sorted(payload.rglob(f"*{ext}")):
                primary = p; break
            if primary: break
        if not primary:
            QMessageBox.warning(parent, "No Word file", "No .docx or .doc file was found in this submission.")
            return
        working = reviews_dir / f"working{primary.suffix.lower()}"
        shutil.copy2(primary, working)
        open_with_default_app(working)
        parent.statusBar().showMessage("Opened working copy.", 4000)
        return

    if mtype == ManuscriptType.LATEX:
        dlg = LatexWorkspace(parent, submission_dir=subdir, reviews_dir=reviews_dir)
        dlg.exec()
        parent.statusBar().showMessage("Workspace closed.", 3000)
        return

    QMessageBox.information(parent, "Unknown type", f"Manuscript type: {mtype}")

def return_submission(info: SubmissionInfo) -> bool:
    """Produce returned.* for a single submission. Returns True if returned."""
    subdir = info.manuscript_root / "submissions" / info.submission_id
    reviews_dir = info.reviews_dir
    events_dir = info.manuscript_root / "events"
    payload = info.payload_dir
    reviews_dir.mkdir(parents=True, exist_ok=True)

    # Word path:
    working_docx = reviews_dir / "working.docx"
    working_doc = reviews_dir / "working.doc"
    if working_docx.exists() or working_doc.exists():
        working = working_docx if working_docx.exists() else working_doc
        shutil.copy2(working, reviews_dir / f"returned{working.suffix.lower()}")
        if not (reviews_dir / "comments.json").exists():
            save_comments_json(reviews_dir, {"general": "Reviewed in Word", "items": []})
        write_event(events_dir, returned_event(info.submission_id))
        return True

    primary_word = None
    for ext in (".docx", ".doc"):
        ps = sorted(payload.rglob(f"*{ext}"))
        if ps: primary_word = ps[0]; break
    if primary_word is not None:
        shutil.copy2(primary_word, reviews_dir / f"returned{primary_word.suffix.lower()}")
        if not (reviews_dir / "comments.json").exists():
            save_comments_json(reviews_dir, {"general": "Reviewed in Word (from submitted file)", "items": []})
        write_event(events_dir, returned_event(info.submission_id))
        return True

    # LaTeX path:
    worktree = reviews_dir / "worktree" if (reviews_dir / "worktree").exists() else payload
    diff_ok, diff_log, diff_pdf = build_diff_pdf(payload, worktree, reviews_dir)
    pdf_path = diff_pdf
    if not diff_ok or not (pdf_path and pdf_path.exists()):
        pdf_path = reviews_dir / "compiled.pdf"
        if not pdf_path.exists():
            main_rel = detect_main_tex(worktree)
            if main_rel:
                _ok, _log, _ = build_pdf(worktree, main_rel, pdf_path)

    comments = load_comments_json(reviews_dir)
    returned_html = reviews_dir / "returned.html"
    title = info.manuscript_title
    write_latex_review_html(
        returned_html,
        title=f"{title} (Returned)",
        has_pdf=bool(pdf_path and pdf_path.exists()),
        pdf_path=pdf_path if (pdf_path and pdf_path.exists()) else None,
        build_log=(diff_log if diff_ok else "(No latexdiff; plain build.)"),
        payload=payload,
        comments=comments,
    )
    if not (reviews_dir / "comments.json").exists():
        save_comments_json(reviews_dir, {"general": "", "items": []})
    write_event(events_dir, returned_event(info.submission_id))
    return True

def set_due_many(infos: Iterable[SubmissionInfo], iso: str, note: str, *, set_by: str) -> None:
    for info in infos:
        write_return_due(info.manuscript_root, info.submission_id, iso, note=note, set_by=set_by)

def clear_due_many(infos: Iterable[SubmissionInfo]) -> None:
    for info in infos:
        write_return_due(info.manuscript_root, info.submission_id, None)

def tooltip_for(info: SubmissionInfo) -> str:
    lines = []
    if info.journal: lines.append(f"Journal:  {info.journal}")
    if info.submitted_iso: lines.append(f"Submitted: {iso_to_local_str(info.submitted_iso)}")
    if info.returned_iso:  lines.append(f"Returned:  {iso_to_local_str(info.returned_iso)}")
    if info.due_iso:
        lines.append(f"Due (student return): {iso_to_local_str(info.due_iso)}")
        if info.due_note: lines.append(f"Due note: {info.due_note}")
    if info.last_edit_iso: lines.append(f"Last edit: {iso_to_local_str(info.last_edit_iso)}")
    return "\n".join(lines)
